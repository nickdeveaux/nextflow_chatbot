# Multi-stage Dockerfile for Railway deployment
# Serves both frontend (Next.js) and backend (FastAPI) in a single container
# Uses a simple reverse proxy to route requests

# ============================================================================
# Stage 1: Build Frontend (Next.js)
# ============================================================================
FROM node:18-alpine AS frontend-builder

WORKDIR /app/frontend

# Copy frontend package files
COPY frontend/package.json frontend/package-lock.json* ./

# Install dependencies
RUN npm ci

# Copy frontend source and config files
COPY frontend/ ./
COPY config.yaml ../config.yaml
COPY scripts/sync-config.js ../scripts/sync-config.js

# Sync config before build
# API_URL will be relative since we serve from same origin
RUN node ../scripts/sync-config.js

# Build Next.js app (standalone mode)
RUN npm run build

# ============================================================================
# Stage 2: Build Backend (Python/FastAPI)
# ============================================================================
FROM python:3.11-slim AS backend-setup

WORKDIR /app

# Install minimal system dependencies
RUN apt-get update && apt-get install -y \
    git \
    && rm -rf /var/lib/apt/lists/*

# Copy config and check script
COPY config.yaml ./
COPY backend/config.py backend/check_index.py ./

# Copy backend directory
COPY backend/ ./backend/

# Check if vector index exists
RUN python check_index.py || echo "Index check: No index found"

# Install production requirements
RUN pip install --no-cache-dir -r backend/requirements.txt

# Create persistent data directory
RUN mkdir -p /app/data

# Move backend code to app root
RUN cp backend/main.py backend/llm_client.py backend/citations.py ./ && \
    cp -r backend/vector_store ./vector_store/ && \
    if [ -f backend/vector_index.index ] && [ -f backend/vector_index.data ]; then \
        cp backend/vector_index.index backend/vector_index.data /app/data/ && \
        echo "✓ Pre-built index files copied"; \
    fi

# Conditionally install build requirements
ARG BUILD_INDEX=false
COPY backend/requirements-build-index.txt* ./
RUN if [ "$BUILD_INDEX" = "true" ] && [ -f requirements-build-index.txt ]; then \
    echo "Installing build requirements..."; \
    pip install --no-cache-dir -r requirements-build-index.txt; \
    fi

# Optional: Clone Nextflow docs
ARG NEXTFLOW_BRANCH=master
RUN if [ "$BUILD_INDEX" = "true" ]; then \
    echo "Cloning Nextflow docs..."; \
    git clone --depth 1 --branch ${NEXTFLOW_BRANCH} https://github.com/nextflow-io/nextflow.git /tmp/nextflow && \
    mv /tmp/nextflow/docs /app/nextflow-docs && \
    rm -rf /tmp/nextflow; \
    fi

# Verify index status
RUN python check_index.py || echo "Final check completed"

# ============================================================================
# Stage 3: Final Production Image
# ============================================================================
FROM python:3.11-slim

WORKDIR /app

# Install Node.js for running Next.js and reverse proxy
RUN apt-get update && apt-get install -y \
    nodejs \
    npm \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy backend from backend-setup stage
COPY --from=backend-setup /app ./

# Copy frontend standalone build
# Next.js standalone output structure varies - we'll handle it in the startup script
RUN mkdir -p /app/frontend-standalone
COPY --from=frontend-builder /app/frontend/.next/standalone ./frontend-standalone
COPY --from=frontend-builder /app/frontend/.next/static ./frontend-standalone/.next/static
COPY --from=frontend-builder /app/frontend/public ./frontend-standalone/public

# Create simple reverse proxy server
RUN cat > /app/proxy.js << 'EOFJS'
const http = require('http');
const httpProxy = require('http-proxy');

const PORT = process.env.PORT || 8000;
const FRONTEND_PORT = 3000;
const BACKEND_PORT = 8001;

const proxy = httpProxy.createProxyServer({});

// Create proxy server
const server = http.createServer((req, res) => {
  const url = req.url;
  
  // Route API calls to FastAPI backend
  if (url.startsWith('/chat') || url.startsWith('/health')) {
    console.log(`[PROXY] ${req.method} ${url} -> Backend :${BACKEND_PORT}`);
    proxy.web(req, res, {
      target: `http://localhost:${BACKEND_PORT}`,
    }, (err) => {
      console.error('[PROXY] Backend error:', err);
      res.writeHead(502, { 'Content-Type': 'text/plain' });
      res.end('Backend service unavailable');
    });
  } else {
    // Route everything else to Next.js frontend
    console.log(`[PROXY] ${req.method} ${url} -> Frontend :${FRONTEND_PORT}`);
    proxy.web(req, res, {
      target: `http://localhost:${FRONTEND_PORT}`,
    }, (err) => {
      console.error('[PROXY] Frontend error:', err);
      res.writeHead(502, { 'Content-Type': 'text/plain' });
      res.end('Frontend service unavailable');
    });
  }
});

proxy.on('error', (err, req, res) => {
  console.error('[PROXY] Proxy error:', err);
  if (!res.headersSent) {
    res.writeHead(502, { 'Content-Type': 'text/plain' });
    res.end('Proxy error');
  }
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`[PROXY] Reverse proxy listening on port ${PORT}`);
  console.log(`[PROXY] Frontend: http://localhost:${FRONTEND_PORT}`);
  console.log(`[PROXY] Backend: http://localhost:${BACKEND_PORT}`);
});
EOFJS

# Install http-proxy for reverse proxy
RUN npm install http-proxy --save --prefix /app

# Create startup script
RUN cat > /app/start.sh << 'EOFSH'
#!/bin/bash
set -e

echo "=========================================="
echo "Starting Nextflow Chat Assistant"
echo "=========================================="

# Start FastAPI backend on internal port 8001 (NOT 8000!)
echo "Starting FastAPI backend on port 8001..."
cd /app
# Use exec to run in background but allow signal handling
uvicorn main:app --host 0.0.0.0 --port 8001 > /tmp/backend.log 2>&1 &
BACKEND_PID=$!
echo "Backend PID: $BACKEND_PID"

# Wait for backend to be ready
echo "Waiting for backend to start..."
for i in {1..30}; do
  if curl -f http://localhost:8001/health > /dev/null 2>&1; then
    echo "✓ Backend is ready!"
    break
  fi
  if [ $i -eq 30 ]; then
    echo "✗ Backend failed to start (check logs)"
    cat /tmp/backend.log
    exit 1
  fi
  sleep 1
done

# Start Next.js frontend
echo "Starting Next.js frontend on port 3000..."
cd /app/frontend-standalone

# Next.js standalone structure: server.js might be in root or a subdirectory
# Common structures:
# - .next/standalone/server.js
# - .next/standalone/frontend/server.js
# - .next/standalone/[package-name]/server.js

# Try to find and use server.js
if [ -f server.js ]; then
  echo "Found server.js in frontend-standalone root"
  SERVER_PATH="./server.js"
elif [ -f frontend/server.js ]; then
  echo "Found server.js in frontend subdirectory"
  cd frontend
  SERVER_PATH="./server.js"
else
  # Search for server.js
  SERVER_JS=$(find . -name "server.js" -type f 2>/dev/null | head -1)
  if [ -z "$SERVER_JS" ]; then
    echo "ERROR: server.js not found"
    echo "Directory contents:"
    ls -la
    echo "Searching for .js files:"
    find . -name "*.js" -type f | head -10
    exit 1
  fi
  echo "Found server.js at: $SERVER_JS"
  SERVER_DIR=$(dirname "$SERVER_JS")
  cd "$SERVER_DIR"
  SERVER_PATH="./server.js"
fi

# Start Next.js server
echo "Starting Next.js from: $(pwd)"
PORT=3000 HOSTNAME=0.0.0.0 node "$SERVER_PATH" > /tmp/frontend.log 2>&1 &
FRONTEND_PID=$!
echo "Frontend PID: $FRONTEND_PID"

# Wait for frontend to be ready
echo "Waiting for frontend to start..."
for i in {1..30}; do
  if curl -f http://localhost:3000 > /dev/null 2>&1; then
    echo "✓ Frontend is ready!"
    break
  fi
  if [ $i -eq 5 ]; then
    echo "Frontend startup log (first 50 lines):"
    head -50 /tmp/frontend.log || echo "No frontend log yet"
  fi
  if [ $i -eq 30 ]; then
    echo "✗ Frontend failed to start (check logs)"
    echo "Full frontend log:"
    cat /tmp/frontend.log
    echo "Directory structure:"
    ls -la /app/frontend-standalone/
    exit 1
  fi
  sleep 1
done

# Start reverse proxy (this is the main process)
echo "Starting reverse proxy on port ${PORT:-8000}..."
echo "=========================================="
cd /app

# Function to cleanup on exit
cleanup() {
  echo "Shutting down..."
  kill $BACKEND_PID $FRONTEND_PID 2>/dev/null || true
  exit 0
}
trap cleanup SIGTERM SIGINT

# Start proxy (runs in foreground as main process)
# Railway provides PORT env var - use it or default to 8000
echo "Railway PORT env var: ${PORT:-8000}"
exec node proxy.js
EOFSH

RUN chmod +x /app/start.sh

EXPOSE 8000

ENV PORT=8000
ENV NODE_ENV=production

# Health check (Railway will use this)
# Note: Railway provides PORT env var, health check uses 8000 as default
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# Use ENTRYPOINT to ensure our script always runs (Railway can't override this)
ENTRYPOINT ["/bin/bash", "/app/start.sh"]
